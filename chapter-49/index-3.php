<?php
/**
 * Недостатки "ручного" перехвата
 *
 * Мы вынуждены заботиться о "ручном" вызове ob_end_clean() в двух различных ситуациях:
 * перед оператором return и в блоке "поимки" всех исключений.
 * Стоит пропустить переключение буфера хотя бы в одном месте, как мы тут же получим трудно обнаруживаемую при отладке ошибку.
 *
 * Использование объектов и деструкторов
 * К счастью, выход существует - это метод "выделение ресурса есть инициализация". А именно, следует воспринимать буфер вывода
 * как некоторый абстрактный ресурс и доверить завершение работы с выходным потоком деструктору некоторого класса.
 * Деструкторы вызываются автоматически всякий раз, когда на соответствующий объект тереяется последняя ссылка в программе. Как раз
 * это и происходит, в частности, при выходе из функций любым способом, будь то исключение или инструкция return.
 *
 * Таким образом, если начать перехват выходного потока в конструкторе класса Output, то можно быть уверенным:
 * при уничтожении объекта данного класса обязательно будет вызван его деструктор, в котором можно завершить перехват (ob_end_clean).
 *
 * Для запуска перехвата необходимо создать объект типа Output из пространтсва имен Buffering, а для остановки перехвата и восстановления
 * предыдущего буфера - этот объект уничтожить (явно или неявно).
 */

 ## Работа с буфером вывода в "объектном" стиле
 spl_autoload_register();
 // Перехватываем выходной поток в программе
 $h = new \Buffering\Output();
 // Текст попадает в буфер
 echo "Начало внешнего перехвата.<br/>";
 // Вызываем функцию, "не зная", что она перехватывает вывод
 $formatted = inner();
 // Печатаем еще текст в буфер
 echo "Конец внешнего перехвата";
 // Формируем некоторый текст по шаблону
 $text = "{$h->__toString()}<br>Функция вернула: \"$formatted\"";
 // Завершаем перехват. Буфер освободится автоматически в деструкторе.
 $h = null;
 // Печатаем то, что накопили в переменной, и заканчиваем работу
 echo $text;
 exit();

 // Функция, перехватывающая выходной поток в своих целях,
 // гарантирует, что при выходе буфер будет восстановлен
 function inner()
 {
     $buf = new \Buffering\Output();
     echo "Этот текст попадет в буфер";
     return "<b>{$buf->__toString()}</b>";
     // Не нужно заботиться о ручном вызове ob_end_clean().
   // Это автоматически делает деструктор объекта $buf!
 }