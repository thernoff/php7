<?php
// Технология отложенного копирования
// Сравним скорость разных видов передачи параметров

// Передача "по значению" без изменения параметра
function takeVal($a) {
    $x = $a[1234];
}

// Передача "по ссылке" без изменения параметра
function takeRef(&$a) {
    $x = $a[1234];
}

// Передача "по значению" с ИЗМЕНЕНИЕМ параметра
function takeValAndModif($a) {
    $a[1234]++;
}

// Передача "по ссылке" с ИЗМЕНЕНИЕМ параметра
function takeRefAndModif(&$a) {
    $a[1234]++;
}

// Тестируем разные функции на скорость
test("takeVal");
test("takeRef");
test("takeValAndModif");
test("takeRefAndModif");

function test($func) {
    // Создаем большой массив
    $a = [];
    for ($i = 1; $i <= 100000; $i++) {
        $a[$i] = $i;
    }
    //Ждем "переключения" секунды (для точности)
    for ($t = time(); $t == time(););
    // Выполняем функцию в течение ровно 1 секунды
    for ($n = 0, $t = time(); time() == $t; $n++) {
        $func($a);
    }
    printf("<tt>$func</tt> took %d itr/sec<br/>", $n);
}

/*
    В результате на экран будет выведено примерно следующее:
    takeVal took 4536910 itr/sec
    takeRef took 4408706 itr/sec
    takeValAndModif took 778 itr/sec
    takeRefAndModif took 3919742 itr/sec

    При вызове функции takeValAndModif будет меньше всего итераций из-за особенности PHP:
    технологии отложенного копирования данных, т.е. при передаче параметра в функцию по значению (должна создаваться копия параметра)
    никакой копии не создается до тех пор, пока не будет происходить изменение переданного значения.
*/