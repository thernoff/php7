<?php
/**
 * Механизм отражений предоставляет разработчику возможность исследования как пользовательских, так и предопределенных классов,
 * выясняя статус и состав отдельных членов, методов, классов и даже расширений PHP, а также объявлять объекты классов и выполнять
 * над ними манипуляции. Кроме этого, отражения позволяют автоматически генерировать документацию иерархии классов по схеме javadoc,
 * применяемой в технологии Java.
 */

 // Вызов функции trim() неявным образом, через переменную $funcName
 $funcName = "trim";
 echo call_user_func($funcName, "    What? What did I just say?     ");
echo "<br/>";
 /**
  * Функция call_user_func() может вызывать также и методы объектов. Для этого вместо первого параметра ей необходимо передать специальный список,
  * который формируется так array(&$obj, "methodName"). Если метод статический и относится к классу, а не к объекту, для его вызова передайте
  * вместо объекта $obj строковое имя класса.
 */

// Неявный вызов метода
class MathComplex2 {
  public $re, $im;

  function __construct($re = 0, $im = 0) {
      $this->re = $re;
      $this->im = $im;
  }

  function add(MathComplex2 $mc) {
      $this->re += $mc->re;
      $this->im += $mc->im;
  }

  function __toString() {
      return "({$this->re}, {$this->im})";
  }
}

$addMethod = "add";
$a = new MathComplex2(101, 303);
$b = new MathComplex2(0, 6);
// Вызываем метод add() неявным образом
call_user_func([$a, $addMethod], $b);
echo $a;

/**
 * Существует и другой способ для неявного вызова метода класса - использование так называемого механизма отражений,
 * или reflection API (см. далее).
 */