<?php
/**
 * Работа с сокетами
 * Функция fsockopen() представляет устаревший подход работы с сетью, через сокеты. До введения потоков fsockopen()
 * была, пожалуй, единственная возможность работать с протоколами на низком уровне.
 * Функция устанавливает сетевое соединение с указанным хостом и программой, закрепленной на нем за портом $port. В качестве
 * результата возвращается файловый дескриптор, с которым затем могут быть выполнены обычные операции: fread(), fwrite(), fgets(), feof() и т.д.
 */

 ## "Эмуляция" браузера
 // Соединяемся с Web-сервером localhost. Обратите внимание, что префикс "http://" не испольуется - информация
 // о протоколе и так содержится в номере порта (80).
 $fp = fsockopen("localhost", 80);
 // Посылаем запрос главной страницы сервера. Конец строки в виде "\r\n" соответствует стандарту протокола HTTP.
 fputs($fp, "GET / HTTP/1.1\r\n");
 // Посылаем обязательный для HTTP 1.1 заголовок Host.
 fputs($fp, "Host: localhost\r\n");
 // Отключаем режим keep-alive, что заставляет сервер СРАЗУ ЖЕ закрыть соединение после посылки ответа,
 // а не ожидать следующего запроса.
 // Попробуйте убрать эту строчку - и работа скрипта сильно замедлится.
 fputs($fp, "Connection: close\r\n");
 // Конец заголовков
 fputs($fp, "\r\n");

 // Теперь читаем по одной строке и выводим ответ
 echo "<pre>";
 while (!feof($fp)) {
   echo htmlspecialchars(fgets($fp, 1000));
 }
 echo "</pre>";
 // Отключаемся от сервера
 fclose($fp);

 /**
  * Неблокирующее чтение
  * int socket_set_blocking(int $sd, int $mode) функция устанавливает блокирующий или неблокирующий режим для соединения, открытого ранее при помощи
  * функции fsockopen().
  * В режиме блокировки ($mode === true) функции чтения будут "засыпать", пока передача данных не завершится. Т.о., если данных много, или же
  * произошел какой-то "затор" в сети, ваша программа остановится и будет дожидаться выхода из функции чтения.
  * В режиме запрета блокировки ($mode == false) функции наподобие fgets() будут сразу же возвращать управление в программу, даже если через соединение
  * не было передано еще ни одного байта данных. Т.о., считывается ровно столько информации, сколько доступно на данный момент. Определить, что
  * данные закончились, можно с помощью функции feof().
  */