<?php
// "Жадность" квантификаторов
$str = "Hello, this <b>word</b> is <b>bold</b>!";
$re = '| <(\w+) [^>]* > (.*) </\1> |xs';
preg_match($re, $str, $matches) or die("Нет тегов");

// Выражение .* захватывает максимально возможное число символов.
// Ниже будет выведено 'word</b> is <b>bold' обрамлено тегом 'b'
echo htmlspecialchars("'$matches[2]' обрамлено тегом '$matches[1]'");
echo "<br/>";
// Если поставить знак ? после любого из квантификаторов *, +, {} или даже ?, мы даем ему "таблетку от жадности".
// Или другими словами делаем квантификатор "ленивым".
$re = '| <(\w+) [^>]* > (.*?) </\1> |xs';
preg_match($re, $str, $matches) or die("Нет тегов");
echo htmlspecialchars("'$matches[2]' обрамлено тегом '$matches[1]'");
echo "<br/>";
// Выражения *?, +?, {}? и ?? следует воспринимать как цельный квантификаторы. Это не составная конструкция,
// а именно одна управляющая последовательность.
// Обычно "ленивые" квантификаторы применяют для поиска конструкций, претендующих на роль парных.
// Пример: удаляем все теги из некоторой строки.
echo preg_replace('/<.+?>/s', '', $str);
echo "<br/>";
// Замена "псевдотегов" [b]...[/b]
$str = "Hello, this [b]word[/b] is [b]bold[/b]!";
echo preg_replace('| \[b\] (.*?) \[/b\] |ixs', '<b>$1</b>', $str);
echo "<br/>";
// К сожалению, "ленивые" квантификаторы - тоже не панацея. Они не делают никаких предположений насчет
// вложенности конструкций.
$str = "[b]жирный текст [b]а тут еще жирнее[/b] вернулись[/b]";
$to = '<b>$1</b>';
$re1 = '| \[b\] (.*) \[/b\] |ixs';
$re2 = '| \[b\] (.*?) \[/b\] |ixs';
$result = preg_replace($re1, $to, $str);
// Жадная версия: <b>жирный текст [b]а тут еще жирнее[/b] вернулись</b>
echo "Жадная версия: " . htmlspecialchars($result) . "<br/>";
$result = preg_replace($re2, $to, $str);
// Ленивая версия: <b>жирный текст [b]а тут еще жирнее</b> вернулись[/b]
echo "Ленивая версия: " . htmlspecialchars($result) . "<br/>";